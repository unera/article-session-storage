## Апгрейд хранимок Tarantool: все своё ношу с собой!

В мире баз данных существует сложная проблема апгрейда хранимых процедур.

Проблема заключается в следующем:

Большой проект обычно состоит из множества относительно независимых друг от друга приложений, использующих
одну и ту же базу данных.

Как правило развитие проекта происходит неравномерно и итеративно:
каждое новое изменение затрагивает лишь несколько составляющих Вашего проекта.

Предположим у Вас имеется хранимая процедура `user_profile`, которая возвращает профиль пользователя по его идентификатору.
Развивая одну из частей проекта Вы решаете что эта функция отныне должна возвращать меньшее число параметров.
Производите рефакторинг функции и кода ее использующего. При интеграционном тестировании выясняется что хранимая процедура
`user_profile` используется так же в других подпроектах и изменение привело к неприятным багам/последствиям.

Как правило сроки поджимают и разработчик стоит на распутье: толи ему отказаться от рефакторинга процедуры, поскольку этот
рефакторинг вызывает проблемы в другом подпроекте, толи ему заняться рефакторингом смежных проектов.

Имеется диалектическое противоречие:

1. Базе данных хорошо исполнять код, который находится в хранимой процедуре;
2. Разработчикам ПО хорошо чтобы этот код лежал в том же Git-дереве, что и код использующий результаты хранимой процедуры;


<cut />

Способы снятия противоречия варьируются от проекта к проекту:


### Версионность в названии хранимых процедур

Многие компании создают внутреннее полиси (зачастую подкрепленное скриптами), которое требует называть хранимые процедуры по определенному правилу.
Например указанную функцию `user_profile` мы переименовываем в `user_profile_0001`, где `0001` - номер её версии. Программист, которому
потребовался рефакторинг этой функции пишет новую - `user_profile_0002`, а `user_profile_0001` продолжает существовать в системе до тех
пор пока весь зависимый на нее код не перепишут.


### Полный отказ от использования хранимых процедур

Я видел многие SQL и не SQL-проекты сознательно отказывающиеся от хранимых процедур ("кроме тех случаев когда совсем уж без них нельзя").
Разрешение противоречия в пользу разработчиков.


### Перенос максимума бизнеслогики в хранимые процедуры

Довольно редкий подход, но тоже встречается. Прямая противоположность предыдущего случая.


БД Tarantool предлагает компромисный вариант снятия данного противоречия: сессионное хранилище
[box.session.storage](https://tarantool.io/en/doc/1.9/book/box/box_session.html#box-session-storage).

Многие БД имеют сессионное хранилище, но увы немногие предоставляют возможность хранить в нем функции/процедуры.

Что такое сессионное хранилище? Это хранилище, которое будет полностью очищено сразу после того как клиент отсоединится от базы данных.


### Использование

Алгоритм использования такой:

1. Клиент коннектится к БД
2. Заполняет сессионное хранилище ссылками на хранимые процедуры, которые будет использовать
3. Работает делая вызовы к созданным процедурам
4. После дисконнекта хранилище очищается

### Плюсы и минусы:


#### Плюсы

1. Код хранимых процедур можно держать в том же Git дереве, что и код их использующий;
2. При необходимости использования одних и тех же процедур в разных проектах можно использовать Git сабмодули;
3. Исправление/рефакторинг хранимки и связанного с ней кода становится простым: правки производятся в одном месте

#### Минусы

1. Компиляция хранимок при каждом коннекте клиента. Если число присоединенных клиентов огромное (тысячи) - может
получаться значительный оверхед по использованию памяти.
2. Данный подход увы не решает вопрос с хранимками продолжающими работать и после дисконнекта клиента.

## Пример

Некоторые драйвера к tarantool позволяют сразу после коннекта автоматически выполнять набор lua файлов из заданной директории.
Например используя [Perl-коннектор DR::Tnt](http://search.cpan.org/~unera/DR-Tnt/lib/DR/Tnt.pm) Вы можете указать опцию `lua_dir`.

Размещаем в директории проекта каталог `lua` в котором можем положить несколько файлов. Например `user.lua` из этого каталога
будет выглядеть так:

```lua

function box.session.storage.user.profile(id)
    local user = box.space.users:get{id}
    local profile = box.space.profiles:get{id}
    -- do something
    return { user, profile }
end

function box.session.storage.user.add(...)
    -- ...
end

function box.session.storage.user.get(id)
    return box.space.users:get{id}
end

```

В приложении коннектимся и работаем используя процедуры `box.session.storage`:

```perl

my $tnt = tarantool
	host 		=> $host,
	port 		=> $port,
	user 		=> $user,
	password	=> $password,
	lua_dir		=> "lua"
;

# создание пользователя с именем Вася
my $new_user = $tnt->call_lua('box.session.storage.user.add', { name => 'Вася' });

# получение пользователя
my $user = $tnt->call_lua('box.session.storage.user.get', 123);

```

## Ссылки

1. [Эта статья на github](https://github.com/unera/session-storage-article)
2. [Проект Tarantool](http://tarantool.org)
3. [box.session.storage в документации](https://tarantool.io/en/doc/1.9/book/box/box_session.html#box-session-storage)

