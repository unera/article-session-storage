## Апгрейд хранимок Tarantool: все своё ношу с собой!

В мире баз данных существует сложная проблема рефакторинга и апгрейда хранимых процедур.

Проблема состоит в том, что существует диалектическое противоречие:

* С точки зрения эффективности работы с данными: желательно максимум бизнеслогики реализовывать в хранимых процедурах;
* С точки зрения эффективности разработки ПО: желательно чтобы составные части одной программы находились в одном месте;


<cut/>

Большой проект традиционно состоит из множества относительно независимых друг от друга приложений, использующих одну и ту же базу данных.

Как правило развитие проекта происходит неравномерно и итеративно: каждое новое изменение затрагивает лишь несколько составляющих Вашего проекта.

Предположим у Вас имеется хранимая процедура `user.profile`, которая возвращает профиль пользователя по его идентификатору. Развивая одну из частей проекта Вы решаете что эта функция отныне должна возвращать меньшее число параметров. Производите рефакторинг функции и кода ее использующего. При интеграционном тестировании выясняется что хранимая процедура `user.profile` используется так же в других подпроектах и произведённое изменение привело к неприятным багам/последствиям.

Когда сроки поджимают (то есть практически всегда) разработчик стоит на распутье:

* Или отказаться от рефакторинга процедуры, поскольку этот рефакторинг вызывает проблемы в другом подпроекте.
* Или заняться рефакторингом и смежных проектов тоже.


Способы снятия указанного противоречия варьируются от проекта к проекту:


### Версионность в названии хранимых процедур

Многие компании создают внутреннее полиси (зачастую подкрепленное скриптами CI), которое требует называть хранимые процедуры по определенному правилу.
Например указанную функцию `user.profile` мы переименовываем в `user.profile_0001`, где `0001` - номер её версии. Программист, которому
потребовался рефакторинг этой функции пишет новую - `user.profile_0002`, а `user.profile_0001` продолжает существовать в системе до тех
пор пока весь зависимый на нее код не перепишут.

Достоинства и недостатки такого подхода очевидны.


### Полный отказ от использования хранимых процедур

Я видел многие SQL и не SQL-проекты сознательно отказывающиеся от хранимых процедур ("кроме тех случаев когда совсем уж без них нельзя").
Разрешение противоречия в пользу разработчиков.


### Перенос максимума бизнеслогики в хранимые процедуры

Довольно редкий подход, но тоже встречается. Прямая противоположность предыдущего случая. Разные приложения при этом вообще не имеют общих хранимых процедур.


### Сессионное хранилище

Многие БД имеют сессионное хранилище, но увы немногие предоставляют возможность хранить в нем функции/процедуры.

БД Tarantool имеет сессионное хранилище, позволяющее хранить в нем в том числе и функции.
[box.session.storage](https://tarantool.io/en/doc/1.9/book/box/box_session.html#box-session-storage).


Что такое сессионное хранилище? Это хранилище, которое будет полностью очищено сразу после того как клиент отсоединится от базы данных.


Как можно использовать сессионное хранилище для решения поставленных проблем? Используем приблизительно следующий алгоритм:

1. Клиент коннектится к БД;
2. Клиент заполняет сессионное хранилище ссылками на хранимые процедуры, которые будет использовать;
3. Работает делая вызовы к созданным процедурам;
4. После дисконнекта хранилище очищается самой БД;

#### Плюсы

1. Код хранимых процедур можно держать в том же Git дереве, что и код их использующий;
2. При необходимости использования одних и тех же процедур в разных проектах можно использовать Git сабмодули;
3. Исправление/рефакторинг хранимки и связанного с ней кода становится простым: правки производятся в одном месте

#### Минусы

1. Компиляция хранимок происходит при каждом коннекте клиента. Если число присоединенных клиентов огромное (тысячи) - может
получаться значительный оверхед по использованию памяти.
2. Данный подход увы не решает вопрос с хранимками продолжающими работать и после дисконнекта клиента.
Работа с такими хранимками - тема отдельной статьи.

## Пример

Некоторые драйвера к tarantool позволяют сразу после коннекта автоматически выполнять набор lua файлов из заданной директории.
Например используя [Perl-коннектор DR::Tnt](http://search.cpan.org/~unera/DR-Tnt/lib/DR/Tnt.pm) Вы можете указать опцию `lua_dir`.

Размещаем в директории проекта каталог `lua` в котором можем положить несколько файлов. Например `user.lua` из этого каталога
будет выглядеть так:

```lua

function box.session.storage.user.profile(id)
    local user = box.space.users:get{id}
    local profile = box.space.profiles:get{id}
    -- do something
    return { user, profile }
end

function box.session.storage.user.add(...)
    -- ...
end

function box.session.storage.user.get(id)
    return box.space.users:get{id}
end

```

В приложении коннектимся и работаем используя процедуры `box.session.storage`:

```perl

my $tnt = tarantool
	host 		=> $host,
	port 		=> $port,
	user 		=> $user,
	password	=> $password,
	lua_dir		=> "lua"
;

# создание пользователя с именем Вася
my $new_user = $tnt->call_lua('box.session.storage.user.add', { name => 'Вася' });

# получение пользователя
my $user = $tnt->call_lua('box.session.storage.user.get', 123);

```



Относительно длинный неймспейс `box.session.storage` можно сократить до минимального размера разместив в глобальном справочнике его алиас:

```lua
_G.ss = box.session.storage

```



## Ссылки

1. [Эта статья на github](https://github.com/unera/session-storage-article)
2. [Проект Tarantool](http://tarantool.org)
3. [box.session.storage в документации](https://tarantool.io/en/doc/1.9/book/box/box_session.html#box-session-storage)

